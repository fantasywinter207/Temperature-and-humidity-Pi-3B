#include "oled.h"
#include <gpiod.h>
#include <unistd.h>
#include <string>

const uint8_t OLED::font5x8[][5] = {
    // ASCII characters 32~127
    // ' ' to '~'
    {0x00,0x00,0x00,0x00,0x00}, // SPACE
    {0x00,0x00,0x5F,0x00,0x00}, // !
    {0x00,0x07,0x00,0x07,0x00}, // "
    {0x14,0x7F,0x14,0x7F,0x14}, // #
    {0x24,0x2A,0x7F,0x2A,0x12}, // $
    {0x23,0x13,0x08,0x64,0x62}, // %
    {0x36,0x49,0x55,0x22,0x50}, // &
    {0x00,0x05,0x03,0x00,0x00}, // '
    {0x00,0x1C,0x22,0x41,0x00}, // (
    {0x00,0x41,0x22,0x1C,0x00}, // )
    {0x14,0x08,0x3E,0x08,0x14}, // *
    {0x08,0x08,0x3E,0x08,0x08}, // +
    {0x00,0x50,0x30,0x00,0x00}, // ,
    {0x08,0x08,0x08,0x08,0x08}, // -
    {0x00,0x60,0x60,0x00,0x00}, // .
    {0x20,0x10,0x08,0x04,0x02}, // /
    {0x3E,0x51,0x49,0x45,0x3E}, // 0
    {0x00,0x42,0x7F,0x40,0x00}, // 1
    {0x42,0x61,0x51,0x49,0x46}, // 2
    {0x21,0x41,0x45,0x4B,0x31}, // 3
    {0x18,0x14,0x12,0x7F,0x10}, // 4
    {0x27,0x45,0x45,0x45,0x39}, // 5
    {0x3C,0x4A,0x49,0x49,0x30}, // 6
    {0x01,0x71,0x09,0x05,0x03}, // 7
    {0x36,0x49,0x49,0x49,0x36}, // 8
    {0x06,0x49,0x49,0x29,0x1E}, // 9
    {0x00,0x36,0x36,0x00,0x00}, // :
    {0x00,0x56,0x36,0x00,0x00}, // ;
    {0x08,0x14,0x22,0x41,0x00}, // <
    {0x14,0x14,0x14,0x14,0x14}, // =
    {0x00,0x41,0x22,0x14,0x08}, // >
    {0x02,0x01,0x51,0x09,0x06}, // ?
    {0x32,0x49,0x79,0x41,0x3E}, // @
    {0x7E,0x11,0x11,0x11,0x7E}, // A
    {0x7F,0x49,0x49,0x49,0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F,0x41,0x41,0x41,0x3E}, // D
    {0x7F,0x49,0x49,0x49,0x41}, // E
    {0x7F,0x48,0x48,0x48,0x40}, // F
    {0x3E,0x41,0x49,0x49,0x3A}, // G
    {0x7F,0x08,0x08,0x08,0x7F}, // H
    {0x41,0x41,0x7F,0x41,0x41}, // I
    {0x20,0x40,0x41,0x41,0x3F}, // J
    {0x7F,0x08,0x14,0x22,0x41}, // K
    {0x7F,0x40,0x40,0x40,0x40}, // L
    {0x7F,0x02,0x04,0x02,0x7F}, // M
    {0x7F,0x04,0x08,0x10,0x7F}, // N
    {0x3E,0x41,0x41,0x41,0x3E}, // O
    {0x7F,0x49,0x49,0x49,0x30}, // P
    {0x3E,0x41,0x41,0x51,0x3E}, // Q
    {0x7F,0x49,0x49,0x49,0x36}, // R
    {0x36,0x49,0x49,0x49,0x2F}, // S
    {0x01,0x01,0x7F,0x01,0x01}, // T
    {0x3F,0x40,0x40,0x40,0x3F}, // U
    {0x1F,0x20,0x40,0x20,0x1F}, // V
    {0x3F,0x40,0x30,0x40,0x3F}, // W
    {0x63,0x14,0x08,0x14,0x63}, // X
    {0x03, 0x0C, 0x70, 0x0C, 0x03}, // Y
    {0x61,0x51,0x49,0x45,0x43}, // Z
};

OLED::OLED() : sda(nullptr), scl(nullptr), chip(nullptr) {
    chip = gpiod_chip_open_by_name(CHIP_NAME);
    sda = gpiod_chip_get_line(chip, SDA_LINE);
    scl = gpiod_chip_get_line(chip, SCL_LINE);

    gpiod_line_request_output(sda, "i2c", 1);
    gpiod_line_request_output(scl, "i2c", 1);
}

OLED::~OLED() {
    if (sda) gpiod_line_release(sda);
    if (scl) gpiod_line_release(scl);
    if (chip) gpiod_chip_close(chip);
}

void OLED::i2cDelay() {
    usleep(1); // 1Âµs delay
}

void OLED::setLine(gpiod_line* line, int value) {
    gpiod_line_set_value(line, value);
    i2cDelay();
}

int OLED::readLine(gpiod_line* line) {
    return gpiod_line_get_value(line);
}

void OLED::i2cStart() {
    setLine(sda, 1);
    setLine(scl, 1);
    setLine(sda, 0);
    setLine(scl, 0);
}

void OLED::i2cStop() {
    setLine(sda, 0);
    setLine(scl, 1);
    setLine(sda, 1);
}

bool OLED::i2cWriteByte(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        setLine(sda, (data & 0x80) ? 1 : 0);
        setLine(scl, 1);
        setLine(scl, 0);
        data <<= 1;
    }

    // Read ACK
    gpiod_line_request_input(sda, "i2c-read");
    setLine(scl, 1);
    int ack = readLine(sda);
    setLine(scl, 0);
    gpiod_line_request_output(sda, "i2c-write", 0);
    return ack == 0;
}

bool OLED::i2cWriteBytes(const uint8_t* data, int length) {
    for (int i = 0; i < length; i++) {
        if (!i2cWriteByte(data[i])) {
            return false;
        }
    }
    return true;
}

void OLED::command(uint8_t cmd) {
    i2cStart();
    i2cWriteByte(0x78);    // Slave address + write
    i2cWriteByte(0x00);    // Control byte: command
    i2cWriteByte(cmd);
    i2cStop();
}

void OLED::data(uint8_t data) {
    i2cStart();
    i2cWriteByte(0x78);
    i2cWriteByte(0x40);    // Control byte: data
    i2cWriteByte(data);
    i2cStop();
}

void OLED::init() {
    command(0xAE); // Display off
    command(0xA6); // Normal display
    command(0x20); command(0x00); // Horizontal mode
    command(0xB0); // Page 0
    command(0xC8); // COM scan direction
    command(0x00); // Low column
    command(0x10); // High column
    command(0x40); // Start line
    command(0x81); command(0x7F); // Contrast
    command(0xA1); // Segment remap
    command(0xA8); command(0x3F); // Multiplex ratio
    command(0xA4); // Display follows RAM
    command(0xD3); command(0x00); // Display offset
    command(0xD5); command(0x80); // Display clock
    command(0xD9); command(0xF1); // Pre-charge
    command(0xDA); command(0x12); // COM pins
    command(0xDB); command(0x40); // VCOMH
    command(0xAF); // Display on
}

void OLED::clear() {
    for (int page = 0; page < 5; page++) { // Iterate through all pages
        command(0xB0 + page);          // Set page address
        command(0x00);                 // Set column address low 4 bits
        command(0x10);                 // Set column address high 4 bits

        for (int col = 0; col < 128; col++) { // Iterate through all columns
            data(0x00); // Send clear data
        }
    }
}

void OLED::drawChar(char c) {
    if (c < 32 || c > 127) c = '?'; // fallback

    for (int i = 0; i < 5; ++i) {
        data(font5x8[c - 32][i]);
    }
    data(0x00);  // Space between characters
}

void OLED::drawText(int page, int col, const std::string& str) {
    command(0xB0 + page);          // Page address
    command(0x00 + (col & 0x0F));  // Column address low 4 bits
    command(0x10 + (col >> 4));    // Column address high 4 bits

    uint8_t buffer[128]; // Data buffer
    int i = 0;
    for (char c : str) {
        for (int j = 0; j < 5; ++j) {
            buffer[i++] = font5x8[c - 32][j];
        }
        buffer[i++] = 0x00; // Space between characters
    }

    // Send buffer data at once
    for (int j = 0; j < i; j++) {
        data(buffer[j]);
    }
}